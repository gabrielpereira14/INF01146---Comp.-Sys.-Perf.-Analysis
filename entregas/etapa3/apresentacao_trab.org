#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LATEX_CLASS: beamer
#+LATEX_HEADER: \setbeamertemplate{itemize item}{\textbullet}
#+LATEX_HEADER: \setbeamertemplate{itemize subitem}{\textbullet}
#+LATEX_HEADER: \setbeamertemplate{itemize subsubitem}{\textbullet}
#+LATEX_HEADER: \setbeamertemplate{headline}{}
#+LATEX_HEADER: \setbeamertemplate{footline}{}
#+LATEX_HEADER: \setbeamertemplate{navigation symbols}{}
#+BEAMER_FRAME_LEVEL: 2

#+TITLE: Medição do impacto de uma infraestrutura de VPN na taxa de transmissão e na latência
#+AUTHOR: Ester Crestani, Gabriel Pereira e Júlia Pimentel
#+DATE: 30/11/2025
#+OPTIONS: toc:nil H:2

* Medição do impacto da infraestrutura de VPN da UFRGS na taxa de transmissão e na latência 
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:

  O objetivo deste trabalho é avaliar o impacto da infraestrutura de VPN da UFRGS, utilizada através do OpenVPN, sobre o throughput, latência, jitter e perda de pacotes.

** Ferramentas utilizadas :noexport:
  - iperf para a coleta de throughput;
  - ping para a coleta de latência, jitter e perda de pacotes.

** Metodologia :noexport:
  Foram desenvolvidos dois scripts para a coleta de dados. O principal é o run_test.py, ele contém as funções que iniciam e param a execução da VPN, além de 
  chamar o script que faz os experimentos do ping. Também contém as funções para a execução dos testes do iperf. Tentou-se separar a parte do iperf em um terceiro script para
  manter uma melhor modularização, entretanto 
  - Execução simultânea de ping e iperf;
  
*** Script principal - run_test.py
  #+BEGIN_SRC python
  import subprocess
  import time
  import sys
  import os
  import argparse
  import platform
  from utils.env_loader import load_env_manual

  import csv     
  from datetime import datetime     
          
  SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
  PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
  SOURCE_FOLDER = f"{PROJECT_ROOT}/src"  
  DATA_DIR = f"{PROJECT_ROOT}/data"  
      
  load_env_manual(os.path.join(PROJECT_ROOT, '.env') ) # carregamento do .env

  USER_NAME = os.getenv('USER_NAME')
  if USER_NAME:
      USER_NAME = USER_NAME.lower()
  else:
      print("Could not find the 'USER_NAME' variable in the .env file.")
      
  os.makedirs(f"{DATA_DIR}/{USER_NAME}", exist_ok=True)

  OPEN_VPN_CONFIG_PATH = os.path.join(SCRIPT_DIR, "ufrgs.ovpn")
  PASS_PATH = os.path.join(SCRIPT_DIR, "pass.txt")
  OPENVPN_CMD = ["sudo", "openvpn", "--config", OPEN_VPN_CONFIG_PATH , "--auth-user-pass", PASS_PATH]

  WAIT_TIME_AFTER_VPN_TOGGLE = 10
  SESSION_DURATION_SECONDS = 240
  IPERF_DURATION = 10
  INTERVAL = 5  

  PING_TEST_OUTPUT_FILE_PATH = os.path.join(DATA_DIR, USER_NAME, "ping_results.csv")
  IPERF_TEST_OUTPUT_FILE_PATH = os.path.join(DATA_DIR, USER_NAME, "iperf_results.csv")   
  IPERF_TEST_OUTPUT_REVERSE = os.path.join(DATA_DIR, USER_NAME, "iperf_results_reversed.csv")   

  IPERF_SERVER = "pcad.inf.ufrgs.br" 
  IPERF_PORT = 8787     

  def kill_vpn() -> None:
      """Mata qualquer processo OpenVPN em execução."""
      subprocess.run(["pkill", "-f", "openvpn"], capture_output=True)
      
  def start_vpn() -> subprocess.Popen:
      """Inicia o OpenVPN."""
      stdout = subprocess.PIPE
      stderr = None
      if DEBUG:
          stdout = None
      return subprocess.Popen(OPENVPN_CMD, stdout=stdout, stderr=stderr)

  def start_ping_test(duration: int, label : str) -> subprocess.Popen:
      cmd = [sys.executable, os.path.join(SOURCE_FOLDER, "run_ping_test.py"), "--duration", str(duration), "--output_path", PING_TEST_OUTPUT_FILE_PATH, "--label", label]
      process = subprocess.Popen(
          cmd,
          stdout=subprocess.DEVNULL,
          stderr=None,
      )
      return process

  def stop_ping_test(process):
      """Para o processo de ping."""
      print("--- [PING] Parando ping... ---")
      try:
          if process.poll() is None:
              process.terminate()
              process.wait()
      except Exception as e:
          print(f"[ERRO ao parar o ping] {e}")
      
      print("--- [PING] Parado. ---")

  def run_iperf_tcp(server, port=8787, duration=10, reverse= False):
      """Roda o iperf TCP e retorna o throughput em Mbps."""
      cmd = ["iperf", "-c", server, "-p", str(port), "-y", "C", "-t", str(duration)]
      if reverse:
          cmd.insert(9, "-R")
      try:
          result = subprocess.run(
              cmd,
              capture_output=True,
              text=True,
              check=True
          )
          output_csv = result.stdout.strip()
          values = output_csv.split(',')
          
          if 'tcp connect failed' in result.stderr and not output_csv:
              print(f"[IPERF TCP ERROR] Falha ao conectar no servidor, garanta que o servidor esteja rodando")
              print(result.stderr)
              print(result.stdout)
              return None
          
          bps = float(values[-1])
          throughput_mbps = bps / 1e6
          return throughput_mbps
      except Exception as e:
          print(f"[IPERF TCP ERROR] {e}")
          return None

  def write_to_csv(row, file):
      """Adiciona uma linha de resultado ao arquivo CSV."""
      file_exists = os.path.isfile(file)

      with open(file, "a", newline="") as f:
          writer = csv.writer(f)
          if not file_exists:
              writer.writerow([
                  "timestamp", "test_label", "tcp_throughput_mbps",
              ])
          writer.writerow(row)
              
  def start_iperf_test(label : str, reverse : bool):
      tcp_throughput = run_iperf_tcp(IPERF_SERVER, IPERF_PORT, IPERF_DURATION, reverse)

      log_label = f"IPERF TCP{ " REVERSO" if reverse else ""}"

      if tcp_throughput is not None:
          print(f" [{log_label}] Throughput: {tcp_throughput:.2f} Mbps")
          timestamp = datetime.now().isoformat()
          row = [
              timestamp, label, tcp_throughput,
          ]
          
          output_file_path = IPERF_TEST_OUTPUT_REVERSE if reverse else IPERF_TEST_OUTPUT_FILE_PATH
          write_to_csv(row, output_file_path)           
          print(f"[{log_label}]: Resultado salvo com sucesso")
      else:
          print(f"[{log_label}] Teste falhou.")
          exit(1)
      return

  def ensure_privileges():
      system = platform.system()

      print(f"Running on {system}")

      if system == "Windows":
          import ctypes
          try:
              is_admin = ctypes.windll.shell32.IsUserAnAdmin()
          except:
              is_admin = False

          if not is_admin:
              args = " ".join(f'"{a}"' for a in sys.argv[1:])
              cmd = [
                  "powershell",
                  "-Command",
                  (
                      f'Start-Process "{sys.executable}" '
                      f'-ArgumentList "{args}" '
                      f'-Verb RunAs -Wait'
                  )
              ]

              result = subprocess.run(cmd)
              sys.exit(result.returncode or 0)

      elif hasattr(os, "geteuid") and os.geteuid() != 0:
          try:
              result = subprocess.run(["sudo", sys.executable, *sys.argv])
              sys.exit(result.returncode or 0)
          except KeyboardInterrupt:
              pass
          sys.exit(1) 

  if __name__ == "__main__":
      parser = argparse.ArgumentParser(description="Script with debug flag")
      parser.add_argument("--debug", action="store_true", help="Enable debug mode")
      args = parser.parse_args()
      DEBUG = args.debug
      
      if DEBUG:
          print("Debug: ON")
          
      ensure_privileges()
      
      print(f"Hello, {USER_NAME}!")
      print("=== VPN Impact Test ===")
      print(f"Resultados do iperf serão salvos em: {IPERF_TEST_OUTPUT_FILE_PATH}")
      print(f"Resultados do ping serão salvos em: {PING_TEST_OUTPUT_FILE_PATH}")
      print("Pressione Ctrl+C para parar.\n")
      
      skip_udp = True
      ping_proc = None
      ping_file = None
      reverse = False

      try:
          while True:
              kill_vpn()
              
              print("\n[SESSÃO VPN ON] Iniciando VPN...")
              vpn_proc = start_vpn()
              time.sleep(WAIT_TIME_AFTER_VPN_TOGGLE) 

              ping_proc = start_ping_test(SESSION_DURATION_SECONDS, "VPN_ON")
              
              session_start_time = time.time()
              print(f"[SESSÃO VPN ON] Rodando iperf (a cada {IPERF_DURATION + INTERVAL}s) por {IPERF_DURATION}s...")
              
              reverse = not reverse
              
              while (time.time() - session_start_time) < SESSION_DURATION_SECONDS:
                  start_iperf_test("VPN_ON", reverse)
                  
                  poll = ping_proc.poll()
                  
                  if poll is not None and poll != 0:
                      print(f"[AVISO] Ping longo (ON) parou inesperadamente. {poll}")
                      break
                  
                  time.sleep(INTERVAL)

              print(f"[SESSÃO VPN ON] Sessão de {SESSION_DURATION_SECONDS / 60} min finalizada.")
              stop_ping_test(ping_proc)
              kill_vpn()
              time.sleep(INTERVAL)

              print("\n[SESSÃO VPN OFF] Garantindo que VPN está parada.")
              kill_vpn()
              
              ping_proc =  start_ping_test(SESSION_DURATION_SECONDS, "VPN_OFF")

              session_start_time = time.time()
              print(f"[SESSÃO VPN OFF] Rodando iperf (a cada {IPERF_DURATION + INTERVAL}s) por {SESSION_DURATION_SECONDS}s...")
              
              while (time.time() - session_start_time) < SESSION_DURATION_SECONDS:
                  start_iperf_test("VPN_OFF", reverse)

                  if poll is not None and poll != 0:
                      print("[AVISO] Ping longo (OFF) parou inesperadamente.")
                      break

                  time.sleep(INTERVAL)
              
              print(f"[SESSÃO VPN OFF] Sessão de {SESSION_DURATION_SECONDS / 60} min finalizada.")
              stop_ping_test(ping_proc)
              
              print(f"\n=== Ciclo completo (ON/OFF). Reiniciando em {INTERVAL}s... ===")
              time.sleep(INTERVAL)

      except KeyboardInterrupt:
          print("\nParado pelo usuário.")
          if ping_proc:
              stop_ping_test(ping_proc)
          kill_vpn()
          print("Script finalizado.")
      except Exception as e:
          exc_type, exc_obj, tb = sys.exc_info()
          line = tb.tb_lineno
          print(f"\n[ERRO FATAL] Ocorreu um erro: {e} na linha {line}")
          if ping_proc:
              stop_ping_test(ping_proc)
          kill_vpn()
  #+END_SRC

** Geração de gráficos 
*** Setup
#+BEGIN_SRC python
import pandas as pd
import os
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import seaborn as sns
import sys

SCRIPT_DIR = os.getcwd()
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
DATA_ROOT = f"{PROJECT_ROOT}/data"
DATE_FMT = mdates.DateFormatter("%d/%m")

def load_user_data(user):
    csv = f"{DATA_ROOT}/{user}/vpn_test_results.csv"
    if not os.path.exists(csv):
        raise FileNotFoundError(csv)
    df = pd.read_csv(csv, parse_dates=["timestamp"])
    df["date"] = df["timestamp"].dt.date
    return df

def ensure_img_dir(user):
    d = f"{PROJECT_ROOT}/{user}/images"
    os.makedirs(d, exist_ok=True)
    return d
#+END_SRC

*** Jitter Plot Function

#+NAME: plot_jitter
#+BEGIN_SRC python :var user=""
df = load_user_data(user)
img_dir = ensure_img_dir(user)

vpn_fixed_day = df[df['test_label'] == 'VPN_ON']['timestamp'].min()

df_j = df.query('timestamp >= "2025.10.01"').copy()
jitter = df_j['ping_jitter_ms']
up = jitter.quantile(0.99)
df_j = df_j[(jitter <= up)]
df_j["timestamp"] = pd.to_datetime(df_j["timestamp"])

fig, axes = plt.subplots(1, 2, figsize=(12, 5))
sns.lineplot(data=df_j.query("test_label == 'VPN_ON'"), x="timestamp", y="ping_jitter_ms", ax=axes[0])
axes[0].set_title("Jitter with VPN")
axes[0].set_xlabel("Date")
axes[0].set_ylabel("ms")

sns.lineplot(data=df_j.query("test_label == 'VPN_OFF'"), x="timestamp", y="ping_jitter_ms", ax=axes[1])
axes[1].set_title("Jitter without VPN")
axes[1].set_xlabel("Date")
axes[1].set_ylabel("ms")

for ax in axes:
    ax.xaxis.set_major_locator(mdates.DayLocator())
    ax.xaxis.set_major_formatter(DATE_FMT)
    ax.tick_params(axis='x', rotation=45)

path = f"{img_dir}/jitter_{user}.png"
plt.tight_layout()
plt.savefig(path, dpi=300)
plt.close()

return path
#+END_SRC

*** Latency Plot Function

#+NAME: plot_latency
#+BEGIN_SRC python :var user=""
df = load_user_data(user)
img_dir = ensure_img_dir(user)

vpn_fixed = df[df['test_label'] == 'VPN_ON']['timestamp'].min()
df_l = df[df['timestamp'] >= vpn_fixed].copy()

lat = df['ping_latency_ms']
lb = lat.quantile(0.01)
ub = lat.quantile(0.99)
df_l = df_l[(lat >= lb) & (lat <= ub)]

fig, axes = plt.subplots(1, 2, figsize=(12, 5))
sns.violinplot(data=df_l.query("test_label == 'VPN_ON'"), x="test_label", y="ping_latency_ms", ax=axes[0], cut=0)
axes[0].set_title("Latency with VPN")

sns.violinplot(data=df_l.query("test_label == 'VPN_OFF'"), x="test_label", y="ping_latency_ms", ax=axes[1], cut=0)
axes[1].set_title("Latency without VPN")

path = f"{img_dir}/latency_{user}.png"
plt.tight_layout()
plt.savefig(path, dpi=300)
plt.close()

return path
#+END_SRC

*** Throughput Plot Function

#+NAME: plot_throughput
#+BEGIN_SRC python :var user=""
df = load_user_data(user)
img_dir = ensure_img_dir(user)

df_t = df.query("tcp_throughput_mbps.notna()").copy()
df_t["timestamp"] = pd.to_datetime(df_t["timestamp"])

fig, axes = plt.subplots(1, 2, figsize=(12, 5))
sns.lineplot(data=df_t.query("test_label == 'VPN_ON'"), x="timestamp", y="tcp_throughput_mbps", ax=axes[0])
axes[0].set_title("Throughput with VPN")
axes[0].set_xlabel("Date")
axes[0].set_ylabel("Mbps")

sns.lineplot(data=df_t.query("test_label == 'VPN_OFF'"), x="timestamp", y="tcp_throughput_mbps", ax=axes[1])
axes[1].set_title("Throughput without VPN")
axes[1].set_xlabel("Date")
axes[1].set_ylabel("Mbps")

for ax in axes:
    ax.xaxis.set_major_formatter(DATE_FMT)
    ax.xaxis.set_major_locator(mdates.DayLocator())
    ax.tick_params(axis='x', rotation=45)

path = f"{img_dir}/throughput_{user}.png"
plt.tight_layout()
plt.savefig(path, dpi=300)
plt.close()

return path
#+END_SRC

*** Latency Heatmap Function

#+NAME: plot_heatmap
#+BEGIN_SRC python :var user=""
df = load_user_data(user)
img_dir = ensure_img_dir(user)

vpn_fixed = df[df['test_label'] == 'VPN_ON']['timestamp'].min()
df_l = df[df['timestamp'] >= vpn_fixed].copy()
df_l['date'] = df_l['timestamp'].dt.date
df_l['hour'] = df_l['timestamp'].dt.hour

p = df_l.pivot_table(values='ping_latency_ms', index='date', columns='hour', aggfunc='mean')

plt.figure(figsize=(14, 8))
sns.heatmap(p, annot=True, fmt=".1f", cmap="rocket_r", linewidths=.5)

plt.xlabel("Hour")
plt.ylabel("Date")
plt.title("Latency Heatmap")

path = f"{img_dir}/heatmap_{user}.png"
plt.tight_layout()
plt.savefig(path, dpi=300)
plt.close()

return path
#+END_SRC


* Presentation 
:PROPERTIES:
:BEAMER_env: ignoreheading
:END:

** Objetivos do trabalho 
- Avaliar o impacto da infraestrutura de VPN da UFRGS

** Metodologia
Execução simultânea de ping e iperf através de um script que alterna entre:
    - Teste com a conexão via OpenVPN UFRGS.
    - Teste com conexão direta.

** Dados coletados
- Coleta automática de: latência, jitter, perda de pacotes (ping), throughput TCP e UDP (iperf3)
- Dados coletados por integrante do grupo, disponiveis dentro da pasta data
- Arquivos: 
    - =ping_results.csv=
    - =iperf_results.csv=
    - =iperf_results_reversed.csv=

** Ambiente de testes
- Servidor iperf: pcad.inf.ufrgs.br
- Site para ping: moodle.ufrgs.br

Autenticação automática via arquivo pass.txt
Intervalos entre testes: 5 segundos
Duração de cada medição: 10 segundos

- Testes realizados em diferentes dias e horários para melhor amostragem

** Material para medição
# Adicionar Script em python utilizado para solicitar as medidas #

** Resultados preliminares:
- Gráficos

** Próximos passos:
- Realizar mais medições em diferentes horários
- Gerar novas análises e indicadores
- Preparar análise crítica para etapa final

#** Slide 3 exemplo para imagem

#[[file:grafico.png]]

#Aqui vai a imagem do slide. 
